# CTI Server - Complete Owner's Guide

Comprehensive overview of all functionality, architecture, operations, and requirements for the CTI Server system.

**Audience:** System owners, CTOs, DevOps engineers, Operations teams

---

## Table of Contents

1. [What is the CTI Server?](#what-is-the-cti-server)
2. [Core Functionality](#core-functionality)
3. [Architecture Overview](#architecture-overview)
4. [System Components](#system-components)
5. [Integration Points](#integration-points)
6. [Security Model](#security-model)
7. [Data Storage & Management](#data-storage--management)
8. [Deployment & Infrastructure](#deployment--infrastructure)
9. [Operations & Monitoring](#operations--monitoring)
10. [Scalability & Performance](#scalability--performance)
11. [Limitations & Constraints](#limitations--constraints)
12. [Disaster Recovery](#disaster-recovery)
13. [Cost Considerations](#cost-considerations)
14. [Troubleshooting & Support](#troubleshooting--support)

---

## What is the CTI Server?

### High-Level Definition

The CTI Server is a **multi-tenant, event-driven integration platform** that:

- **Bridges** your internal systems (CRM, contact center software, etc.) with **Dialpad's** cloud telephony platform
- **Processes** real-time call events (incoming, outgoing, ended, voicemail) from Dialpad
- **Exposes** APIs for your backend systems to query call history, manage integrations, and receive webhooks
- **Provides** WebSocket support for real-time call notifications in web/mobile applications

### What Problem Does It Solve?

**Without CTI Server:**

```
Your Backend â†’ Dialpad API (REST polling only) â†’ Call events arrive 30+ seconds late
              â†’ No real-time notifications
              â†’ Complex OAuth management
              â†’ Limited multi-tenant support
```

**With CTI Server:**

```
Dialpad Webhooks â†’ CTI Server (real-time queue) â†’ Your Backend (instant events via WebSocket)
OAuth handled   â†’ Single integration point      â†’ Rich APIs for call context
Multi-tenant    â†’ Isolates each customer's data â†’ Audit trail for compliance
```

### Key Benefits

| Feature                    | Benefit                                                |
| -------------------------- | ------------------------------------------------------ |
| **Webhook Processing**     | Real-time call events (< 500ms latency)                |
| **Multi-Tenant Isolation** | Support multiple customers/apps without cross-talk     |
| **OAuth Management**       | Automatic token refresh, scope validation, audit trail |
| **API Gateway**            | Unified interface to Dialpad, hiding complexity        |
| **WebSocket Support**      | Browser-based call notifications without polling       |
| **Audit Logging**          | Full history of API key rotations and auth events      |
| **Production Ready**       | Bcrypt hashing, HMAC signatures, CSRF protection       |

---

## Supported Features

### âœ… What This CTI Server Does

**Real-Time Call Management**

- âœ… Incoming call webhook handling from Dialpad
- âœ… Call status events (ringing, active, held, ended)
- âœ… Outbound call tracking and monitoring
- âœ… Real-time WebSocket notifications for call updates
- âœ… Multi-tenant app isolation (separate databases per tenant)

**Call Context & Intelligence**

- âœ… Screen pop (retrieve contact on call arrival via API)
- âœ… Phone number lookup (search by from/to number)
- âœ… Call logs with full history (queryable, indexed)
- âœ… Call metadata (duration, recording URL, timestamps)
- âœ… User/agent mapping (link Dialpad users to CRM users)
- âœ… Call context enrichment (add CRM data to call records)

**Voicemail Management**

- âœ… Voicemail event handling from Dialpad
- âœ… Voicemail transcripts (AI-generated by Dialpad)
- âœ… Recording URLs (access voicemail audio)
- âœ… Voicemail metadata (duration, timestamp, caller)
- âœ… Callback task creation from voicemail

**Authentication & Security**

- âœ… OAuth 2.0 flow with PKCE (Proof Key for Code Exchange)
- âœ… API key management (bcrypt hashed, one-time delivery)
- âœ… API key rotation and revocation
- âœ… API key audit trail (all operations logged)
- âœ… Bearer token authentication (internal endpoints)
- âœ… HMAC-SHA256 webhook signature verification
- âœ… CSRF protection (state parameter validation)

**Integration & Querying**

- âœ… REST API for querying calls/voicemails
- âœ… WebSocket subscriptions for real-time events
- âœ… Call filtering (by status, direction, date, phone, user)
- âœ… Pagination support (large result sets)
- âœ… Multi-format event payloads (JSON, JSONB)
- âœ… Custom event handler extensibility

**Data Management & Compliance**

- âœ… Call detail records (CDR) export
- âœ… Data retention policies (configurable)
- âœ… GDPR "right to be forgotten" support
- âœ… Activity audit logs (who did what, when)
- âœ… Immutable audit trail (cannot be modified)
- âœ… Database encryption at rest (recommended)

**Operational Features**

- âœ… Health check endpoints (/health, /metrics)
- âœ… Event processing queue (handles webhook bursts)
- âœ… Automatic token refresh (no re-authentication needed)
- âœ… Connection pooling (optimized database access)
- âœ… Error logging and monitoring
- âœ… Exponential backoff retry logic

---

### âŒ What This CTI Server Does NOT Do

**Call Handling (Must be Implemented in Your Backend)**

- âŒ Route calls to agents (you handle via Dialpad API)
- âŒ IVR/phone menu (handle in Dialpad or backend)
- âŒ Call transfer logic (Dialpad API responsibility)
- âŒ Call recording (Dialpad handles, CTI just provides URL)
- âŒ Conference management (Dialpad feature)

**Features Requiring External Integration**

- âŒ Phone ringing (implement in your softphone/UI)
- âŒ Contact lookup (query your own CRM)
- âŒ Activity logging (create records in your system)
- âŒ Task/ticket creation (use your CRM API)
- âŒ Notifications/alerts (implement email, SMS, push)
- âŒ Call quality metrics (Dialpad's responsibility)

**Advanced Features**

- âŒ Call transfer tracking (Dialpad limitation)
- âŒ Conference details (Dialpad doesn't expose)
- âŒ Custom call routing (must code in backend)
- âŒ IVR menu press tracking (Dialpad limitation)
- âŒ Call annotation/editing (voicemail only)
- âŒ Sentiment analysis (requires external AI service)

---

## Feature Comparison

| Feature            | CTI Server | Your Backend | Dialpad           |
| ------------------ | ---------- | ------------ | ----------------- |
| Receive webhooks   | âœ… Yes     | -            | âœ… Sends          |
| Queue events       | âœ… Yes     | -            | -                 |
| Process events     | âœ… Yes     | Consumes     | -                 |
| Store call records | âœ… Yes     | Can also     | -                 |
| Screen pop         | âœ… API     | âœ… Implement | -                 |
| Contact lookup     | -          | âœ… You do    | -                 |
| Phone ringing      | -          | âœ… You do    | âœ… Dialpad user   |
| Token management   | âœ… Yes     | -            | âœ… OAuth provider |
| API key validation | âœ… Yes     | -            | -                 |

---

## Core Functionality

### 1. **Real-Time Call Event Processing**

**What It Does:**

- Receives call events from Dialpad (ringing, answered, held, ended)
- Stores events in a durable queue
- Asynchronously processes events every 5 seconds
- Matches events to call records
- Triggers WebSocket notifications to subscribed clients

**Supported Events:**

- `call.ring` â†’ Incoming/outgoing call ringing
- `call.started` â†’ Call answered
- `call.held` â†’ Call placed on hold
- `call.resumed` â†’ Hold released
- `call.ended` â†’ Call disconnected
- `voicemail.received` â†’ Voicemail left

**Example Use Cases:**

- Ring agent's phone when call arrives
- Update CRM in real-time as call progresses
- Pop contact record when call starts
- Auto-log call history when call ends
- Alert manager when important customer calls

### 2. **Voicemail Management**

**What It Does:**

- Receives voicemail events from Dialpad
- Extracts recording URL and transcript
- Creates voicemail records in database
- Makes data available via API
- Supports both download and on-demand streaming

**Features:**

- Automatic transcript generation (via Dialpad)
- Recording URL accessible for configurable period
- Metadata: duration, caller, timestamp
- Multi-language support (depends on Dialpad)

**Example Use Cases:**

- Create callback task from voicemail transcript
- Email voicemail transcripts to users
- Archive voicemails in CRM
- Build voicemail analytics

### 3. **Call History & Querying**

**What It Does:**

- Maintains persistent call records in PostgreSQL
- Allows querying by date, status, direction, phone number, user
- Supports filtering by app/tenant
- Provides pagination for large result sets

**Queryable Fields:**

- Call ID, direction (inbound/outbound), status
- From/to phone numbers, duration
- Dialpad user ID, assigned CRM user
- Recording URL, voicemail flag
- Start/end timestamps

**Performance:**

- Indexed on app_id + started_at (O(log n) lookup)
- Partial index for active calls
- GIN index for JSONB payload searching

**Example Use Cases:**

- Pull call history for compliance audits
- Generate inbound/outbound call reports
- Find calls with specific phone numbers
- Export CDR (Call Detail Record) data

### 4. **OAuth 2.0 Authorization Flow**

**What It Does:**

- Manages Dialpad OAuth tokens for each tenant
- Implements PKCE (Proof Key for Code Exchange) for security
- Automatically refreshes tokens before expiration
- Stores tokens in database with encryption
- Handles token revocation on disconnect

**Scope Management:**

- `calls:list` - Read call history and active call data
- `recordings_export` - Access recording URLs
- `offline_access` - Long-lived refresh tokens (no re-auth)

**Security Features:**

- PKCE prevents authorization code interception
- State parameter prevents CSRF attacks
- Tokens refreshed automatically (transparent to backend)
- Failed refresh triggers re-authorization prompt

**Token Lifecycle:**

```
User clicks "Connect to Dialpad"
    â†“
CTI Server generates PKCE challenge
    â†“
Redirects to Dialpad OAuth screen (scopes shown)
    â†“
User approves scopes (one-time)
    â†“
Dialpad redirects back with authorization code
    â†“
CTI Server exchanges code for access + refresh tokens (PKCE verified)
    â†“
Tokens stored in database
    â†“
Every N days: Automatic refresh (transparent)
    â†“
~6 months later: Refresh token expires, user re-authenticates
```

**Example Use Cases:**

- Connect customer's Dialpad account without sharing passwords
- Automatically pull call data from Dialpad API
- Support multiple Dialpad orgs per tenant

### 5. **API Key Management**

**What It Does:**

- Generates secure API keys for each tenant app
- Hashes keys with bcrypt (cannot be reversed)
- Validates keys on every API request
- Tracks key rotations in audit log
- One-time key delivery (never retrievable again)

**Security Model:**

- Key format: `raw_<64 hex chars>`
- Stored in database as bcrypt hash
- Plain key shown only at generation
- Lost key requires regeneration
- Old keys invalidated immediately upon rotation

**Audit Trail:**

- All key operations logged with timestamp
- Can identify when key was created/rotated/revoked
- Useful for compliance audits

**Example Use Cases:**

- Secure API access for backend systems
- Rotate keys quarterly for security
- Revoke keys if compromised
- Audit who created/changed keys

### 6. **User Mapping & Context**

**What It Does:**

- Links Dialpad users to your internal CRM/employee IDs
- Enriches call records with context (which agent took call, assigned to which department)
- Enables call routing and reporting by internal user

**Data Structure:**

```
Dialpad User ID: 12345
    â†“
CTI Server User Mapping
    â†“
Your CRM User ID: "agent_john_smith" or "emp_001" or any identifier
```

**Use Cases:**

- Track calls per agent for performance metrics
- Route calls to correct department
- Assign follow-up tasks to correct team
- Generate departmental call reports

### 7. **WebSocket Real-Time Notifications**

**What It Does:**

- Opens persistent connection between client and server
- Pushes call events as they happen (no polling)
- Supports multiple concurrent connections per app
- Automatic reconnection with exponential backoff

**Event Types Pushed:**

- `call.started` - Call is active
- `call.held` - Call on hold
- `call.resumed` - Hold released
- `call.ended` - Call finished
- `voicemail.received` - Voicemail arrived

**Advantages Over Polling:**
| Polling (1 request/2sec) | WebSocket (push) |
|--------------------------|-----------------|
| ~40 requests/min | 1 connection |
| Latency: 1-2 seconds | Latency: <500ms |
| High API usage | Minimal bandwidth |
| Server load: high | Server load: low |

**Example Use Cases:**

- Real-time call center dashboard
- Browser-based phone integration
- Mobile app notifications
- Live team collaboration UI

### 8. **Webhook Signature Verification**

**What It Does:**

- Validates HMAC-SHA256 signatures on all incoming webhooks
- Prevents webhook spoofing/unauthorized requests
- Uses constant-time comparison (prevents timing attacks)
- Logs failed verifications

**Security Flow:**

```
Dialpad sends webhook with HTTP header:
  X-Dialpad-Signature: hmac_sha256_hex_string

CTI Server:
  1. Extracts webhook body as raw bytes
  2. Computes HMAC-SHA256(body, secret)
  3. Constant-time comparison with received signature
  4. Accept if match, reject with 401 if not
```

**Example Use Cases:**

- Ensure webhooks only from Dialpad
- Prevent replay attacks
- Detect man-in-the-middle interference
- Meet compliance requirements (PCI, SOC 2)

---

## Architecture Overview

### System Diagram

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚         EXTERNAL SYSTEMS                â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                          â”‚                          â”‚
        â–¼                          â–¼                          â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Dialpadâ”‚              â”‚  Your CRM   â”‚          â”‚ Mobile/Web App â”‚
    â”‚ Cloud  â”‚              â”‚   Backend   â”‚          â”‚   (Browser)    â”‚
    â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                          â”‚                          â”‚
        â”‚ Webhooks         REST API + HMAC           WebSocket JSON
        â”‚ OAuth tokens     (x-api-key header)        (api_key in URL)
        â”‚ Call data                â”‚                          â”‚
        â”‚                          â”‚                          â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚    CTI SERVER (Node.js)         â”‚
                    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
                    â”‚  â”‚ Express HTTP Router     â”‚   â”‚
                    â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
                    â”‚  â”‚ /health                 â”‚   â”‚
                    â”‚  â”‚ /authorize (OAuth)      â”‚   â”‚
                    â”‚  â”‚ /webhooks (Dialpad)     â”‚   â”‚
                    â”‚  â”‚ /api/calls (Query)      â”‚   â”‚
                    â”‚  â”‚ /ws (WebSocket)         â”‚   â”‚
                    â”‚  â”‚ /internal/* (Admin)     â”‚   â”‚
                    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
                    â”‚                                 â”‚
                    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
                    â”‚  â”‚ Event Processor         â”‚   â”‚
                    â”‚  â”‚ (runs every 5 seconds)  â”‚   â”‚
                    â”‚  â”‚ - Fetches unprocessed   â”‚   â”‚
                    â”‚  â”‚   webhook_events        â”‚   â”‚
                    â”‚  â”‚ - Matches to handlers   â”‚   â”‚
                    â”‚  â”‚ - Updates call records  â”‚   â”‚
                    â”‚  â”‚ - Pushes WebSocket msgs â”‚   â”‚
                    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
                    â”‚                                 â”‚
                    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
                    â”‚  â”‚ Authentication          â”‚   â”‚
                    â”‚  â”‚ - API Key (bcrypt)      â”‚   â”‚
                    â”‚  â”‚ - Bearer tokens         â”‚   â”‚
                    â”‚  â”‚ - HMAC verification     â”‚   â”‚
                    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                     â”‚
                                     â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   PostgreSQL Database           â”‚
                    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
                    â”‚  â”‚ apps                    â”‚   â”‚
                    â”‚  â”‚ dialpad_connections     â”‚   â”‚
                    â”‚  â”‚ api_key_audit_log       â”‚   â”‚
                    â”‚  â”‚ calls                   â”‚   â”‚
                    â”‚  â”‚ messages                â”‚   â”‚
                    â”‚  â”‚ voicemails              â”‚   â”‚
                    â”‚  â”‚ webhook_events          â”‚   â”‚
                    â”‚  â”‚ dialpad_users           â”‚   â”‚
                    â”‚  â”‚ user_mappings           â”‚   â”‚
                    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Data Flow: Inbound Call

```
Timeline:
T+0s   Dialpad detects incoming call
       â””â”€â†’ Generates call.ring event
           â””â”€â†’ Sends webhook with HMAC signature
               â””â”€â†’ CTI Server /webhooks endpoint

T+0.1s CTI Server verifies HMAC signature
       â””â”€â†’ Extracts app_id from Dialpad org_id mapping
           â””â”€â†’ Inserts raw event into webhook_events queue
               â””â”€â†’ Returns 200 OK to Dialpad

T+0.2s Your backend polls WebSocket for new events
       â””â”€â†’ Receives call.ring event in real-time
           â””â”€â†’ Rings agent's phone
               â””â”€â†’ Starts UI timer

T+5s   Event processor picks up event
       â””â”€â†’ Calls call.ring handler
           â””â”€â†’ Inserts into calls table with status='ringing'
               â””â”€â†’ Pushes update to all WebSocket subscribers
                   â””â”€â†’ Browsers/mobiles receive update

T+5.1s Your backend queries /api/calls/active
       â””â”€â†’ Sees new call in results
           â””â”€â†’ Updates CRM with call context
```

### Data Flow: Webhook Processing Queue

```
Dialpad sends 1,000 webhooks/minute to your CTI Server
       â”‚
       â”œâ”€â†’ All validated and queued in webhook_events table
       â”‚   (Dialpad retries until 200 OK received)
       â”‚
       â”œâ”€â†’ Event Processor runs every 5 seconds
       â”‚   T+0s:  Picks up first 100 events
       â”‚   T+1s:  Process event #1 (insert into calls table)
       â”‚   T+2s:  Process event #2
       â”‚   ...
       â”‚   T+5s:  Process event #100
       â”‚
       â”œâ”€â†’ Next cycle (T+5s):
       â”‚   T+5s:  Event Processor runs again
       â”‚   Picks up events #101-200
       â”‚   ...
       â”‚
       â””â”€â†’ Result: ~200 webhooks processed per second
           (depends on database performance)
```

---

## System Components

### 1. Web Server (Express.js)

**Purpose:** HTTP/WebSocket endpoint for all integrations

**Key Routes:**

| Route                         | Method | Purpose                  | Auth        |
| ----------------------------- | ------ | ------------------------ | ----------- |
| `/health`                     | GET    | Health check             | None        |
| `/metrics`                    | GET    | System metrics           | Bearer      |
| `/authorize`                  | GET    | Initiate OAuth           | Query param |
| `/auth/dialpad/callback`      | GET    | OAuth redirect           | Session     |
| `/api/calls`                  | GET    | List call records        | API Key     |
| `/api/calls/active`           | GET    | Get active calls         | API Key     |
| `/api/calls/{id}`             | GET    | Get single call          | API Key     |
| `/api/voicemails/{id}`        | GET    | Get voicemail metadata   | API Key     |
| `/webhooks/dialpad`           | POST   | Receive Dialpad webhooks | HMAC        |
| `/internal/apps`              | POST   | Create app               | Bearer      |
| `/internal/apps/{id}/api-key` | POST   | Generate API key         | Bearer      |
| `/ws`                         | WS     | WebSocket subscribe      | API Key     |

**Middleware Stack:**

```
Request
  â†“
[CORS]
  â†“
[Request logging]
  â†“
[Route-specific auth] â† Checks API key, Bearer token, or HMAC
  â†“
[Handler]
  â†“
Response (JSON or WebSocket frame)
```

**Performance Characteristics:**

- Handles ~500 concurrent connections
- ~1000 requests/second on standard hardware
- WebSocket connections: ~50-100ms per message

### 2. Event Processor

**Purpose:** Asynchronously processes queued webhooks

**Operation:**

```javascript
Every 5 seconds:
  1. SELECT * FROM webhook_events WHERE processed_at IS NULL LIMIT 100
  2. For each event:
     - Parse event_type (call.ring, call.started, etc.)
     - Call appropriate handler (callEventHandlers.js)
     - Handler updates calls/voicemails/messages tables
     - Update processed_at timestamp
  3. Push WebSocket notifications to subscribers
  4. Log any errors to logger
```

**Advantages:**

- âœ… Decouples webhook receipt from processing
- âœ… Survives brief database outages (events queue)
- âœ… Survives brief app crashes (events persist)
- âœ… Batches database operations (higher throughput)
- âš ï¸ Introduces ~5 second latency

**Error Handling:**

- Failed handler â†’ Error logged, event marked with error message
- Database down â†’ Event stays in queue, retried next cycle
- App crashed â†’ Events persist, processed when app restarts

### 3. Database (PostgreSQL)

**Version:** 12+ (required for JSONB support)

**Key Tables:**

```sql
-- Tenant Management
apps (id, name, api_key hash, is_active)
dialpad_connections (app_id, dialpad_org_id, access_token, refresh_token)

-- API Security
api_key_audit_log (app_id, action, old_key_hint, new_key_hint, timestamp)

-- Call Data
calls (dialpad_call_id, direction, from, to, status, duration, recording_url, raw_payload)
messages (dialpad_message_id, direction, from, to, text)
voicemails (dialpad_call_id, from, to, recording_url, transcript, duration)

-- Event Queue
webhook_events (dialpad_event_id, event_type, payload, received_at, processed_at)

-- User Context
dialpad_users (dialpad_user_id, app_id, name, email)
dialpad_user_mappings (dialpad_user_id, crm_user_id)
```

**Indexes:** 28 total

- Performance indexes on app_id + timestamp (most queries)
- Partial index for active calls only
- GIN index for JSONB payload searching

**Backup Strategy:**

- Automated daily snapshots (recommended)
- Point-in-time recovery (30+ days recommended)
- Test restore procedures quarterly

### 4. OAuth Token Manager

**Purpose:** Manages token lifecycle for each tenant

**Responsibilities:**

| Operation                | When                             | How                                   | Impact                 |
| ------------------------ | -------------------------------- | ------------------------------------- | ---------------------- |
| Exchange code for tokens | After user approves scopes       | POST /oauth2/token                    | Happens once per user  |
| Refresh access token     | Before expiration (hourly check) | POST /oauth2/token with refresh_token | Transparent to backend |
| Revoke tokens            | On disconnect or user logout     | POST /oauth2/deauthorize              | App loses access       |
| Validate tokens          | Before each API call to Dialpad  | Check expiration time                 | No extra API call      |

**Token Storage:**

```sql
-- Encrypted at rest (database-level encryption recommended)
access_token: "token_abc123..." (short-lived, ~1 hour)
refresh_token: "refresh_abc123..." (long-lived, ~6 months)
expires_at: TIMESTAMP (when access_token expires)
updated_at: TIMESTAMP (when last refreshed)
```

**Failure Scenarios:**

| Scenario              | Behavior                                 | Recovery                          |
| --------------------- | ---------------------------------------- | --------------------------------- |
| Access token expired  | Automatic refresh on next API call       | Transparent                       |
| Refresh token expired | API returns 401                          | User re-authenticates via OAuth   |
| Dialpad API down      | Retry with exponential backoff           | Uses cached/stale token           |
| Network timeout       | Fail-open: use cached token if available | Manual intervention if persistent |

### 5. Webhook Signature Validator

**Purpose:** Ensure webhooks are from Dialpad

**Algorithm:**

```
HMAC-SHA256(webhook_body, DIALPAD_WEBHOOK_SECRET)
```

**Implementation:**

```javascript
// Get signature from header
const receivedSig = req.headers["x-dialpad-signature"];

// Compute expected signature
const expectedSig = crypto
  .createHmac("sha256", webhookSecret)
  .update(req.body)
  .digest("hex");

// Constant-time comparison (prevents timing attacks)
if (
  !crypto.timingSafeEqual(Buffer.from(receivedSig), Buffer.from(expectedSig))
) {
  return res.status(401).json({ error: "Invalid signature" });
}
```

**Security Properties:**

- âœ… Cannot forge signatures without secret
- âœ… Cannot replay old webhooks (body changes)
- âœ… Constant-time comparison (no timing leaks)
- âœ… Works even if HTTPS compromised (at transport layer)

---

## Integration Points

### 1. Backend System Integration

**Your backend can:**

```javascript
// Option A: Receive events via WebSocket (recommended)
const ws = new WebSocket("wss://cti-server.com/ws?api_key=...");
ws.on("message", (event) => {
  // Real-time call events
  updateCRM(event);
});

// Option B: Poll API for updates
setInterval(async () => {
  const calls = await fetch("/api/calls/active", {
    headers: { "x-api-key": apiKey },
  });
  syncCRM(calls);
}, 2000);

// Option C: Hybrid (WebSocket + fallback polling)
subscribeWebSocket();
setInterval(verifyState, 30000);
```

**Common Workflows:**

```javascript
// Workflow 1: CTI-driven updates
Dialpad webhook â†’ CTI queue â†’ Event processor â†’ calls table â†’ WebSocket
Your backend â† WebSocket event â†’ Update CRM â†’ Ring phone

// Workflow 2: Backend queries CTI
Your backend â†’ /api/calls/active â†’ Get active calls â†’ Update UI

// Workflow 3: Create user mapping for context
POST /internal/apps/{id}/users/map
  { dialpad_user_id: 123, crm_user_id: "emp_001" }
â†’ Future calls from user 123 include crm_user_id in response
```

### 2. Dialpad Integration

**CTI Server calls Dialpad for:**

| API                          | When                | Why                           |
| ---------------------------- | ------------------- | ----------------------------- |
| POST /oauth2/token           | At OAuth callback   | Exchange auth code for tokens |
| POST /oauth2/token (refresh) | Before token expiry | Refresh access token          |
| GET /api/v2/calls            | On demand           | Query call history            |
| POST /oauth2/deauthorize     | On disconnect       | Revoke tokens                 |

**Dialpad calls CTI Server for:**

| Event        | When               | Data                                |
| ------------ | ------------------ | ----------------------------------- |
| Webhook POST | Call events occur  | call.ring, call.started, call.ended |
| Webhook POST | Voicemail received | voicemail.received with transcript  |

**OAuth Scopes Required:**

```
calls:list - Read call history and status
recordings_export - Access recording URLs
offline_access - Refresh tokens without re-auth
```

### 3. CRM/Contact Center Integration

**Typical Integration Pattern:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Inbound Call    â”‚
â”‚  Arrives at      â”‚
â”‚  Dialpad         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”œâ”€â†’ CTI Server webhook_events queue
         â”‚
         â”œâ”€â†’ (5 second delay)
         â”‚
         â”œâ”€â†’ Event processor â†’ calls table
         â”‚
         â”œâ”€â†’ WebSocket notification
         â”‚
         â””â”€â†’ Your CRM Backend
             â”‚
             â”œâ”€â†’ Look up contact in database
             â”œâ”€â†’ Create activity record
             â”œâ”€â†’ Assign to agent
             â”œâ”€â†’ Open contact record in UI
             â””â”€â†’ Ring agent's phone
```

**Data You Can Extract:**

- âœ… Phone number (from_number, to_number)
- âœ… Call timing (started_at, ended_at, duration)
- âœ… Recording URL (for on-demand playback)
- âœ… Voicemail transcript (for callback context)
- âœ… Agent assigned (via user mapping)
- âœ… Call disposition (active, ended, held)

**Data You Should Manage:**

- ğŸ”’ Contact lookups (search by phone in your CRM)
- ğŸ”’ Activity creation (log calls in your system)
- ğŸ”’ User assignments (which agent, which queue)
- ğŸ”’ Follow-up tasks (callbacks, notes)

---

## Security Model

### 1. API Key Security

**Generation:**

```
User requests: POST /internal/apps/{id}/api-key
CTI generates: raw_<64 random hex chars>
Hashes with:   bcrypt (cost factor 10)
Stores hash:   In database (plain key never stored)
Returns:       Plain key to user ONE TIME ONLY
```

**Validation on Request:**

```
User sends:     x-api-key: raw_a1b2c3d4...
CTI Server:     - Loads all active app hashes
                - Loops through each: bcrypt.compare(plainKey, hash)
                - On match: app_id authenticated
                - On no match: 401 Unauthorized
```

**Security Properties:**

- âœ… Cannot be reversed (bcrypt is one-way)
- âœ… Database breach doesn't reveal keys
- âœ… Different key per request won't match (bcrypt salt)
- âœ… Lost keys require regeneration (not retrievable)
- âš ï¸ Slightly slower (bcrypt by design)

### 2. Webhook Security

**Validation:**

```
Incoming webhook
  â”‚
  â”œâ”€â†’ Extract X-Dialpad-Signature header
  â”‚
  â”œâ”€â†’ Compute HMAC-SHA256(body, DIALPAD_WEBHOOK_SECRET)
  â”‚
  â”œâ”€â†’ Constant-time compare with received signature
  â”‚
  â””â”€â†’ Accept if match, reject with 401 if not
```

**Properties:**

- âœ… Verifies webhook is from Dialpad
- âœ… Detects tampering (body modification)
- âœ… Prevents replay attacks (different body = different sig)
- âœ… Works even if network compromised

### 3. OAuth Security

**PKCE (Proof Key for Code Exchange):**

```
CTI Server generates:
  code_verifier = random 32 bytes (hex)
  code_challenge = SHA256(code_verifier) base64url

Sends to Dialpad:
  POST /authorize?code_challenge=...&code_challenge_method=S256

Dialpad redirects back with:
  authorization_code = <temporary code>

CTI Server exchanges using:
  POST /oauth2/token
    code: authorization_code
    code_verifier: (the original verifier)
```

**Protection Against:**

- âœ… Authorization code interception (attacker can't use without verifier)
- âœ… Browser history leaks
- âœ… Referer header leaks
- âœ… Man-in-the-middle attacks

**State Parameter (CSRF):**

```
CTI Server generates:
  state = base64(JSON.stringify({ app_id, timestamp }))

Sends to Dialpad:
  POST /authorize?state=...

User approves, redirects back with:
  state=<same value>

CTI Server verifies:
  state in request == state in session
  â†’ If match: safe (user came back from Dialpad)
  â†’ If mismatch: CSRF attack suspected, reject
```

### 4. Data Encryption

**In Transit:**

- âœ… All APIs require HTTPS (no HTTP in production)
- âœ… WebSocket connections use WSS (secure)
- âœ… TLS 1.2+ (no SSL 3.0, TLS 1.0, 1.1)

**At Rest:**

- âš ï¸ Access tokens stored in database
  â†’ Recommend: Database-level encryption (AWS KMS, GCP Cloud KMS)
  â†’ Or: Application-level encryption (before storing)
- âš ï¸ API key hashes stored in database
  â†’ Bcrypt hashes are cryptographically secure
  â†’ No encryption needed (one-way)

**Recommended Encryption:**

```
Before storing access_token:
  encrypted_token = encrypt(access_token, DATABASE_ENCRYPTION_KEY)
  â†’ Store encrypted_token in database

On retrieval:
  access_token = decrypt(encrypted_token, DATABASE_ENCRYPTION_KEY)
  â†’ Use to call Dialpad API
```

### 5. Session Management

**For OAuth Flow:**

```javascript
req.session.pkceVerifier = codeVerifier; // Short-lived
req.session.oauthState = state; // Cleared after callback

// Session destroyed after callback completes
delete req.session.pkceVerifier;
delete req.session.oauthState;
```

**Properties:**

- âœ… PKCE verifier stored only in server memory (not database)
- âœ… Cleared immediately after use
- âœ… Cannot be stolen from database
- âœ… Session cookie expires (httpOnly, Secure flags)

### 6. Audit Trail

**What's Logged:**

```sql
-- API Key changes
INSERT INTO api_key_audit_log (app_id, action, old_key_hint, new_key_hint, performed_at)
  VALUES (app_id, 'created', null, 'raw_abcd...6789', now());

-- OAuth connects/disconnects
dialpad_connections table tracks:
  - When tokens created/updated
  - Dialpad org_id connected
  - Environment (sandbox/prod)

-- All API requests
Application logger records:
  - Route accessed
  - Auth method (API key, Bearer)
  - Status code
  - Duration
  - Error messages (if any)
```

**For Compliance:**

```bash
# Who created/rotated API keys?
SELECT app_id, app_name, action, new_key_hint, performed_at
FROM api_key_audit_log
WHERE action IN ('created', 'rotated')
ORDER BY performed_at DESC;

# When was app connected to Dialpad?
SELECT app_id, dialpad_org_id, updated_at
FROM dialpad_connections
ORDER BY updated_at DESC;

# Which webhooks failed to process?
SELECT event_type, dialpad_event_id, payload, error_message, received_at
FROM webhook_events
WHERE processed_at IS NULL OR error_message IS NOT NULL
ORDER BY received_at DESC;
```

---

## Data Storage & Management

### 1. Data Retention Policy

**Recommended Approach:**

| Table                 | Retention | Reason                         | Deletion Method                      |
| --------------------- | --------- | ------------------------------ | ------------------------------------ |
| `calls`               | 1-2 years | Legal compliance, call history | Automated cleanup job                |
| `voicemails`          | 90 days   | Regulatory, storage costs      | Soft-delete with archive             |
| `messages`            | 1-2 years | Legal, audit                   | Automated cleanup job                |
| `webhook_events`      | 30 days   | Debugging, audit               | Automated cleanup job                |
| `api_key_audit_log`   | 2-3 years | Compliance, security audit     | Immutable (never delete)             |
| `dialpad_connections` | Keep      | Active token storage           | Only delete on disconnect            |
| `apps`                | Keep      | Tenant records                 | Never delete (soft-delete if needed) |

**Implementation:**

```sql
-- Delete old call records (1 year old)
DELETE FROM calls
WHERE created_at < NOW() - INTERVAL '1 year'
AND app_id = $1;

-- Archive voicemails (soft-delete)
UPDATE voicemails
SET is_archived = true
WHERE created_at < NOW() - INTERVAL '90 days';

-- Clean webhook queue (keep only last 30 days)
DELETE FROM webhook_events
WHERE received_at < NOW() - INTERVAL '30 days'
AND processed_at IS NOT NULL;
```

**Backup Strategy:**

```
Daily at 2 AM UTC:
  â”œâ”€â†’ Full database snapshot
  â”œâ”€â†’ Store on separate storage (AWS S3, Azure Blob)
  â””â”€â†’ Retain 30+ days of snapshots

Weekly:
  â”œâ”€â†’ Test restore from backup
  â””â”€â†’ Document procedure

Annually:
  â”œâ”€â†’ Long-term archive (1+ years for compliance)
  â””â”€â†’ Secure, offline backup
```

### 2. Database Size Growth

**Estimates for 1,000 calls/day per app:**

| Table          | Records/day | Size/day | Size/year |
| -------------- | ----------- | -------- | --------- |
| calls          | 1,000       | ~500 KB  | ~180 MB   |
| webhook_events | 1,000       | ~200 KB  | ~73 MB    |
| voicemails     | 50          | ~50 KB   | ~18 MB    |
| messages       | 200         | ~100 KB  | ~36 MB    |

**For 10 apps Ã— 1,000 calls/day:**

- Annual database size: ~3 GB
- Recommended PostgreSQL: 20 GB (6-7 year retention)

**For 100 apps Ã— 1,000 calls/day:**

- Annual database size: ~30 GB
- Recommended PostgreSQL: 200+ GB

**Scaling Solution:**

- Timeline (0-1 year): Single PostgreSQL instance (t3.large: 16 GB)
- Timeline (1-3 years): Horizontal partitioning by app_id or date
- Timeline (3+ years): Read replicas for query offload

### 3. Data Privacy & Compliance

**GDPR Compliance:**

```
Right to be Forgotten:
  1. User requests deletion of their data
  2. Identify all records with user's phone number
  3. Delete from calls, messages, voicemails, webhook_events
  4. Logs remain (immutable)
  5. Confirm deletion

Example:
  DELETE FROM calls WHERE from_number = '+1-415-555-1234';
  DELETE FROM messages WHERE from_number = '+1-415-555-1234';
  DELETE FROM voicemails WHERE from_number = '+1-415-555-1234';
  -- webhook_events: anonymize user context, keep event for audit
```

**Data Residency:**

```
If required by regulation:
  â”œâ”€â†’ PostgreSQL must run in specific geography
  â”œâ”€â†’ Backups stored in same region
  â”œâ”€â†’ Dialpad API calls may have different residency
  â””â”€â†’ Ensure compliance with service terms
```

---

## Deployment & Infrastructure

### 1. System Requirements

**Minimum (Development/Testing):**

- CPU: 2 cores
- RAM: 2 GB
- Storage: 50 GB
- Database: PostgreSQL locally
- Network: Any (HTTPS recommended)

**Recommended (Production, < 1,000 calls/day):**

- CPU: 4 cores (c5.large or equivalent)
- RAM: 8 GB
- Storage: 100 GB SSD
- Database: PostgreSQL 12+ (managed RDS or self-hosted with backups)
- Network: 100 Mbps, HTTPS enforced

**Production Scale (> 10,000 calls/day):**

- CPU: 8+ cores (c5.xlarge or equivalent)
- RAM: 16+ GB
- Storage: 500 GB SSD
- Database: PostgreSQL with read replicas + connection pooling
- Network: 1 Gbps, load balanced, auto-scaling

### 2. Deployment Options

**Option 1: Docker Container (Recommended)**

```dockerfile
FROM node:18-alpine
WORKDIR /app
COPY . .
RUN npm install --production
EXPOSE 4000
CMD ["npm", "start"]
```

**Deploy to:**

- AWS ECS / Fargate
- Google Cloud Run
- Azure Container Instances
- Kubernetes (EKS, GKE, AKS)
- Docker Compose (development)

**Option 2: Virtual Machine**

```bash
# Ubuntu 22.04 LTS
curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
sudo apt-get install -y nodejs postgresql-client

cd /opt/cti-server
npm install --production
pm2 start index.js --name cti-server
pm2 startup
pm2 save
```

**Option 3: Managed Platform**

- Heroku (dyno.standard)
- Railway
- Render
- AWS App Runner

### 3. Network Configuration

**Firewall Rules:**

```
Allow inbound:
  â”œâ”€â†’ Port 4000/TCP from: 0.0.0.0/0 (public API)
  â”œâ”€â†’ Port 443/TCP from: 0.0.0.0/0 (HTTPS)
  â”œâ”€â†’ Port 5432/TCP from: [your-app-ip] (database, if remote)
  â””â”€â†’ SSH access (22/TCP) from: [admin-ip] only

Allow outbound:
  â”œâ”€â†’ HTTPS (443) to: dialpad.com
  â”œâ”€â†’ DNS (53) to: 8.8.8.8
  â””â”€â†’ Database (5432) to: [postgres-ip]
```

**SSL/TLS Certificate:**

- Use HTTPS in all environments except local development
- Obtain from Let's Encrypt (free) or CA
- Renew automatically (certbot, acme)
- Implement HSTS header

### 4. Environment Configuration

**Production .env:**

```env
# Server
PORT=4000
NODE_ENV=production
LOG_LEVEL=info

# Database (use managed service!)
DB_HOST=cti-db.c3p0fnq6vy5u.us-east-1.rds.amazonaws.com
DB_PORT=5432
DB_USER=cti_app
DB_PASSWORD=<use-secrets-manager>
DB_NAME=CTI
DB_POOL_MIN=5
DB_POOL_MAX=20

# OAuth (sandbox for testing, prod for live)
DIALPAD_SANDBOX_CLIENT_ID=...
DIALPAD_SANDBOX_CLIENT_SECRET=<use-secrets-manager>
DIALPAD_PROD_CLIENT_ID=...
DIALPAD_PROD_CLIENT_SECRET=<use-secrets-manager>
DIALPAD_SANDBOX_BASE_URL=https://sandbox.dialpad.com
DIALPAD_PROD_BASE_URL=https://dialpad.com
DIALPAD_SANDBOX_REDIRECT_URI=https://api.yourcompany.com/auth/dialpad/callback
DIALPAD_PROD_REDIRECT_URI=https://api.yourcompany.com/auth/dialpad/callback

# Webhooks
DIALPAD_WEBHOOK_SECRET=<use-secrets-manager>

# Security
INTERNAL_API_SECRET=<use-secrets-manager>
JWT_SECRET=<use-secrets-manager>

# Logging
LOG_TRANSPORT=cloudwatch  # Or: file, console
```

**Secret Management:**

```
Use:
  âœ… AWS Secrets Manager
  âœ… HashiCorp Vault
  âœ… Google Cloud Secret Manager
  âœ… Azure Key Vault

Don't use:
  âŒ .env files in Git
  âŒ Hardcoded values
  âŒ Shared passwords
```

### 5. Database Setup

**PostgreSQL Installation:**

```bash
# AWS RDS (recommended for production)
- Engine: PostgreSQL 14+
- Instance: db.t3.small (1 GB RAM, multi-AZ)
- Storage: 100 GB gp3, auto-scaling to 200 GB
- Backups: 30-day retention, automated daily
- Monitoring: CloudWatch, RDS Performance Insights
- Security: VPC, security groups, encryption at rest

# Self-Hosted (less recommended)
sudo apt-get install postgresql-14
sudo -u postgres psql < DB_Schema.sql

# Connection pooling (required for production)
PgBouncer: external connection pooler
RDS Proxy: AWS managed (recommended)
```

**Initial Setup:**

```bash
# Connect to PostgreSQL
psql -h cti-db.c3p0fnq6vy5u.us-east-1.rds.amazonaws.com \
     -U cti_app \
     -d CTI

# Run schema
\i DB_Schema.sql

# Verify
\dt  -- Should list 11 tables
\di  -- Should list 28+ indexes

# Test connection from app
npm test database
```

---

## Operations & Monitoring

### 1. Health Checks

**Endpoint: GET /health**

```bash
curl https://your-cti-server.com/health

Response:
{
  "status": "healthy",
  "timestamp": "2026-01-30T12:00:00Z"
}
```

**Monitor:**

- Check every 30 seconds
- Alert if down for > 2 minutes
- Alert if response time > 1 second

**Endpoint: GET /metrics**

```bash
curl -H "Authorization: Bearer $INTERNAL_API_SECRET" \
     https://your-cti-server.com/metrics

Response:
{
  "uptime_seconds": 604800,
  "memory_usage_mb": 245,
  "active_connections": 42,
  "total_requests": 1234567,
  "error_rate": 0.001,
  "avg_response_time_ms": 45,
  "database_connection_pool": {
    "idle": 8,
    "active": 12,
    "waiting": 0
  },
  "event_processor": {
    "processed_last_minute": 1245,
    "queue_length": 23,
    "error_count": 1,
    "avg_processing_time_ms": 12
  }
}
```

**Key Metrics to Monitor:**

| Metric                       | Alert Threshold    | Action                                  |
| ---------------------------- | ------------------ | --------------------------------------- |
| Response time (p95)          | > 1000ms           | Investigate slow queries                |
| Error rate                   | > 1%               | Check logs, webhook validation failures |
| Memory usage                 | > 80% of allocated | Restart app, investigate leaks          |
| Database connections         | > 90% of pool      | Reduce concurrency, scale DB            |
| Event processor lag          | > 1 minute         | Increase pool size, optimize handlers   |
| Active WebSocket connections | Trending up        | Check for connection leaks              |

### 2. Logging

**Log Levels:**

```
ERROR (Production threshold)
  â””â”€ API request failed
  â””â”€ Database connection lost
  â””â”€ OAuth token refresh failed

WARN
  â””â”€ Slow query (> 500ms)
  â””â”€ Event handler failed
  â””â”€ Webhook verification failed

INFO (Default level)
  â””â”€ Server started
  â””â”€ App created
  â””â”€ API key rotated
  â””â”€ Dialpad connected

DEBUG (Development only)
  â””â”€ HTTP request/response bodies
  â””â”€ Database queries
  â””â”€ Token refresh flow
```

**Log Destinations:**

```
Development:
  â†’ Console (stdout)

Production:
  â†’ Centralized logging service:
    âœ… AWS CloudWatch
    âœ… Google Cloud Logging
    âœ… ELK Stack (Elasticsearch, Logstash, Kibana)
    âœ… Datadog
    âœ… New Relic
```

**Example Log Entry:**

```json
{
  "timestamp": "2026-01-30T12:00:45.123Z",
  "level": "ERROR",
  "service": "cti-server",
  "route": "POST /webhooks/dialpad",
  "app_id": "550e8400-e29b-41d4-a716-446655440000",
  "message": "Event handler failed",
  "error": "column raw_payload does not exist",
  "stack": "Error at Database.query (db.js:42:15)",
  "duration_ms": 234,
  "correlation_id": "abc123-def456"
}
```

### 3. Alerting

**Critical Alerts (page on-call):**

```
Server is down (health check failed for 2+ minutes)
Database is down (cannot connect)
Error rate > 5%
Event processor lag > 5 minutes
All API keys invalid (unlikely but...)
```

**Warning Alerts (email, Slack):**

```
Memory usage > 75%
P95 response time > 1 second
Webhook validation failures > 10/minute
Database slow query (> 1 second)
Event processor queue length > 1000
```

**Implementation:**

```yaml
# Example: AWS CloudWatch alarm
{
  "MetricName": "HTTPErrorCount",
  "Namespace": "CTIServer",
  "Statistic": "Sum",
  "Period": 60,
  "EvaluationPeriods": 2,
  "Threshold": 50,
  "ComparisonOperator": "GreaterThanOrEqualToThreshold",
  "AlarmActions": ["arn:aws:sns:..."],
}
```

### 4. Dashboard

**Recommended Metrics:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         CTI Server Operations               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                             â”‚
â”‚  Status: âœ… Healthy                        â”‚
â”‚  Uptime: 45 days 3 hours                   â”‚
â”‚  Response Time: 125ms (p95)                â”‚
â”‚                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Requests Last Hour:        42,134           â”‚
â”‚ Errors Last Hour:          12 (0.03%)       â”‚
â”‚ Active WebSocket Conn:     234              â”‚
â”‚ Database Pool:             12/20 active     â”‚
â”‚                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Call Events Processed:     1,245 (this min) â”‚
â”‚ Webhook Queue Backlog:     34 events        â”‚
â”‚ Processing Latency:        4.2 seconds      â”‚
â”‚                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Scalability & Performance

### 1. Bottleneck Analysis

**Current Limitations (Single Node):**

| Component               | Capacity           | Bottleneck          | Solution                       |
| ----------------------- | ------------------ | ------------------- | ------------------------------ |
| Node.js process         | ~1000 req/s        | CPU/Memory          | Horizontal scaling             |
| WebSocket connections   | ~500-1000          | Memory (each ~50KB) | Load balancer                  |
| PostgreSQL (1 instance) | ~100-200 queries/s | Query throughput    | Connection pooling, replicas   |
| Event processor         | ~200 webhooks/s    | Database writes     | Batch processing, partitioning |

### 2. Horizontal Scaling

**Architecture:**

```
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚   Load Balancer      â”‚
         â”‚   (TCP port 4000)    â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚           â”‚           â”‚
        â–¼           â–¼           â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ App #1  â”‚ â”‚ App #2  â”‚ â”‚ App #3  â”‚
    â”‚ Node.js â”‚ â”‚ Node.js â”‚ â”‚ Node.js â”‚
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
         â”‚           â”‚           â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                       â”‚
         â–¼                       â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  PostgreSQL Primary â”‚  â”‚ Replica  â”‚
    â”‚  (reads + writes)   â”‚  â”‚ (reads)  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Benefits:**

- âœ… Requests distributed across 3 nodes
- âœ… WebSocket connections spread (3x capacity)
- âœ… Database writes still go to primary
- âœ… Reads can use replicas
- âœ… Auto-scaling during traffic spikes

**Implementation:**

```javascript
// Load balancer config (AWS ALB, NGINX, HAProxy)
Sticky sessions: ON (WebSocket clients stay on same node)
Health check: GET /health (30s interval)
Deregistration: 30s grace period (finish requests)
```

### 3. Database Optimization

**Connection Pooling:**

```
Without pooling:
  Each Node.js app creates 20 connections
  3 apps Ã— 20 = 60 connections
  PostgreSQL maximum: 100
  â†’ Exhausts quickly

With PgBouncer (recommended):
  Each Node.js app uses pool size: 5-10
  3 apps Ã— 10 = 30 connections to PgBouncer
  PgBouncer creates: ~20 connections to PostgreSQL
  â†’ Efficient multiplexing
```

**Query Optimization:**

```sql
-- BEFORE: Slow (N+1 queries)
SELECT * FROM calls WHERE app_id = $1 AND status = 'active';
-- For each call, app queries: SELECT * FROM dialpad_users WHERE dialpad_user_id = ?

-- AFTER: Fast (single query)
SELECT c.*, du.name AS user_name
FROM calls c
LEFT JOIN dialpad_users du ON c.dialpad_user_id = du.dialpad_user_id
WHERE c.app_id = $1 AND c.status = 'active';
```

**Index Verification:**

```sql
-- Ensure indexes are used
EXPLAIN ANALYZE
SELECT * FROM calls
WHERE app_id = '550e8400-e29b-41d4-a716-446655440000'
AND started_at > NOW() - INTERVAL '24 hours'
ORDER BY started_at DESC;

-- Should show:
-- Index Scan using idx_calls_app_started on calls
-- (if not, index is missing or query wrong)
```

### 4. Event Processor Scaling

**Single Node (5-second cycle):**

```
Cycle 1 (T+0s):   Process events 1-100
Cycle 2 (T+5s):   Process events 101-200
Cycle 3 (T+10s):  Process events 201-300
...
Throughput: ~100 events per 5 seconds = 20 events/sec
```

**Multi-Node Coordination:**

```javascript
// Only one instance should run event processor
// Use database lock to coordinate

async function runEventProcessor() {
  // Try to acquire lock (only succeeds on one node)
  const lockAcquired = await pool.query(
    `SELECT pg_advisory_lock(999);`, // Global lock
  );

  if (!lockAcquired) {
    // Another node is processing, wait for next cycle
    return;
  }

  try {
    // Process events
    const events = await pool.query(
      `SELECT * FROM webhook_events WHERE processed_at IS NULL LIMIT 100 FOR UPDATE SKIP LOCKED`,
    );

    // Process each event...
  } finally {
    // Release lock
    await pool.query(`SELECT pg_advisory_unlock(999);`);
  }
}

setInterval(runEventProcessor, 5000);
```

---

## Limitations & Constraints

### 1. Known Limitations

| Limitation                            | Impact                         | Workaround                                           |
| ------------------------------------- | ------------------------------ | ---------------------------------------------------- |
| Event processing latency              | 5-10 second delay              | Use polling API for latency-critical features        |
| API key not recoverable               | Lost key requires regeneration | Store keys securely, implement key rotation schedule |
| WebSocket max 500-1000 per node       | High traffic needs scaling     | Use load balancer, horizontal scaling                |
| Dialpad rate limits apply             | API calls may be throttled     | Implement exponential backoff, cache responses       |
| No built-in call recording storage    | Recording URLs expire          | Download and archive recordings separately           |
| Single event processor per deployment | Coordination required          | Use database advisory locks (as shown above)         |

### 2. Scalability Limits

**Before Infrastructure Changes:**

| Metric                   | Limit      | Timeline                           |
| ------------------------ | ---------- | ---------------------------------- |
| Concurrent API requests  | ~1000/sec  | First 6 months                     |
| WebSocket connections    | ~1000      | After 1 year                       |
| Call records in database | ~1 million | After 2 years (with daily cleanup) |
| Event processing backlog | < 1 second | Maintained indefinitely            |

**Required Actions:**

```
At 500 calls/day per app:
  â†’ Keep 1 Node.js instance, upgrade database to db.t3.medium

At 5,000 calls/day per app:
  â†’ Scale to 3 Node.js instances, use database read replicas

At 50,000+ calls/day per app:
  â†’ Add caching layer (Redis)
  â†’ Implement query result caching
  â†’ Archive old call records
  â†’ Consider call record sharding
```

### 3. Feature Gaps

**Not Supported:**

- âŒ Voicemail annotation/transcription editing
- âŒ Call transfer tracking
- âŒ IVR/menu press tracking
- âŒ Custom call routing logic (must be in your backend)
- âŒ Conference call details (Dialpad limitation)

**Workarounds:**

- Store custom data in your backend
- Query raw_payload JSONB field for Dialpad-specific data
- Implement custom handlers in callEventHandlers.js

---

## Disaster Recovery

### 1. Backup Strategy

**Critical Components:**

| Component     | Backup Method       | Frequency         | Retention          | Recovery Time |
| ------------- | ------------------- | ----------------- | ------------------ | ------------- |
| PostgreSQL    | Automated snapshots | Daily at 2 AM UTC | 30 days            | < 5 minutes   |
| Source Code   | Git repository      | Every commit      | Forever            | < 1 minute    |
| Configuration | Secrets manager     | Encrypted vault   | Forever            | < 1 minute    |
| OAuth tokens  | Database            | Continuous        | N/A (auto-refresh) | Automatic     |

**Backup Testing:**

```bash
# Monthly: Test restore process
1. Take snapshot of production database
2. Restore to staging environment
3. Run smoke tests (GET /health, sample API calls)
4. Verify all call records present
5. Confirm indices are working
6. Document recovery time
```

### 2. Failure Scenarios

**Scenario 1: Database Connection Lost**

```
Impact: Cannot create new call records
Timeline:
  T+0s   Database goes down
  T+1s   Connection pool exhausted, new requests fail (500 error)
  T+5s   WebSocket clients disconnected (no database access)
  T+10s  Event processor halted (cannot write records)

Recovery:
  1. Databases comes back online
  2. App automatically reconnects (connection pool reset)
  3. Outstanding webhooks stay in queue (processed_at = NULL)
  4. T+30s: Event processor resumes, catches up
  5. No data loss

Prevention:
  âœ… Database redundancy (RDS Multi-AZ)
  âœ… Connection pooling with retries
  âœ… Health checks alert immediately
```

**Scenario 2: Dialpad API Unreachable**

```
Impact: Cannot refresh tokens, OAuth fails
Timeline:
  T+0s   Dialpad API returns 503 (down)
  T+5s   Token refresh fails (new requests use cached token)
  T+10s  Cached token expires, calls to Dialpad start failing

Recovery:
  1. Use stale access_token from database (if not expired)
  2. Retry with exponential backoff (wait 30s, 1m, 2m)
  3. Dialpad recovers
  4. Token refresh succeeds
  5. Normal operation resumes

Prevention:
  âœ… Token cache (don't always refresh)
  âœ… Exponential backoff (don't hammer API)
  âœ… Status monitoring (get alerts early)
```

**Scenario 3: Node.js App Crash**

```
Impact: Requests fail temporarily
Timeline:
  T+0s   Unhandled exception in handler
  T+0.1s Node.js process exits
  T+0.5s Load balancer detects unhealthy (failed health check)
  T+1s   Load balancer removes instance from rotation
  T+2s   Orchestrator restarts container (Docker/Kubernetes)
  T+5s   New instance healthy, back in rotation

Impact: Minimal (other instances handle traffic)
Data loss: None (webhooks stay in queue, processed later)

Prevention:
  âœ… Error handling in all routes
  âœ… Process manager (PM2, systemd, Docker)
  âœ… Auto-restart on crash
```

### 3. Recovery Procedures

**Step 1: Assess the Problem**

```bash
# Check server health
curl https://your-cti-server.com/health

# Check logs
tail -f /var/log/cti-server/error.log

# Check database
psql -h localhost -U cti_app -d CTI -c "SELECT COUNT(*) FROM calls;"

# Check metrics
curl -H "Authorization: Bearer $INTERNAL_API_SECRET" \
     https://your-cti-server.com/metrics
```

**Step 2: Failover Procedures**

```
If primary database down:
  1. Promote read replica to primary
  2. Update connection string in app config
  3. Restart app instances
  4. Run full test suite

If primary app instance down:
  1. Load balancer automatically removes it
  2. Restart or replace instance
  3. Verify health check passes
  4. Load balancer adds back to rotation

If entire region down:
  1. Fail over to disaster recovery region
  2. Restore database from backup
  3. Deploy app to new region
  4. Update DNS / routing
  5. Run full validation
```

**Step 3: Data Validation After Recovery**

```sql
-- Check for data integrity
SELECT
  COUNT(*) as total_calls,
  MAX(created_at) as newest_call,
  MIN(created_at) as oldest_call
FROM calls;

-- Verify indices
\di  -- Should list all expected indices

-- Check for orphaned records
SELECT COUNT(*) FROM calls WHERE app_id NOT IN (SELECT id FROM apps);
  -- Should be 0

-- Verify webhook queue (should be mostly processed)
SELECT
  COUNT(*) as unprocessed,
  COUNT(*) FILTER (WHERE processed_at IS NOT NULL) as processed
FROM webhook_events;
  -- unprocessed should be < 100 (recent events)
```

---

## Cost Considerations

### 1. Monthly Cost Estimate

**Small Deployment (< 1,000 calls/day):**

```
AWS Infrastructure:
  EC2 t3.small (app)          : $20/month
  RDS PostgreSQL t3.small     : $30/month
  EBS storage (50 GB)         : $5/month
  Data transfer               : $2/month
  CloudWatch / Monitoring     : $5/month
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Total Infrastructure        : ~$62/month

Dialpad API (depends on your agreement)
  Typical: $100-500/month (separate from CTI Server)

Total Estimated Cost        : $162-562/month
```

**Medium Deployment (5,000-10,000 calls/day):**

```
AWS Infrastructure:
  EC2 (3x t3.medium)          : $90/month
  RDS PostgreSQL t3.medium    : $60/month
  RDS Read Replica            : $60/month
  EBS storage (200 GB)        : $20/month
  Data transfer (10 GB/month) : $10/month
  CloudWatch / Monitoring     : $10/month
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Total Infrastructure        : ~$250/month

Total Estimated Cost        : $250-750/month
```

### 2. Cost Optimization

**Reduce Costs:**

```
1. Archive old call records (delete after 1 year)
   â†’ Reduces storage costs by 20-30%

2. Use Spot instances for staging
   â†’ 70% cost reduction on non-critical workloads

3. Schedule app scale-down during low traffic
   â†’ Save 20-40% on compute (non-24/7 operation)

4. Use database backup retention (not snapshots)
   â†’ Save on storage costs

5. Implement query caching with Redis
   â†’ Reduce database load, smaller instance needed
```

### 3. Budget Tracking

```
Monthly:
  1. Export AWS billing
  2. Compare to baseline
  3. Identify anomalies

Quarterly:
  1. Forecast costs for next quarter
  2. Plan capacity upgrades
  3. Review cost/unit metrics (cost per call)

Annually:
  1. License review (Node.js, PostgreSQL - all free)
  2. Contract negotiation (AWS, Dialpad)
  3. Architecture cost optimization
```

---

## Troubleshooting & Support

### 1. Common Issues

**Issue: "Cannot connect to database"**

```
Check:
  1. PostgreSQL service running?
     â†’ Windows: Services â†’ PostgreSQL
     â†’ Linux: systemctl status postgresql

  2. DB credentials correct in .env?
     â†’ psql -h <host> -U <user> -d <dbname>

  3. Firewall allowing connection?
     â†’ ping <db-host>
     â†’ telnet <db-host> 5432

  4. Database exists?
     â†’ psql -l | grep CTI

Solution:
  If remote database:
    â†’ Check security group inbound rules
    â†’ Verify app instance can reach database IP
    â†’ Enable SSL if required by RDS
```

**Issue: "API key authentication failing (401)"**

```
Check:
  1. API key generated?
     â†’ POST /internal/apps/{id}/api-key

  2. API key stored correctly in environment?
     â†’ Check header: x-app-api-key: raw_...

  3. API key not rotated?
     â†’ Old keys invalidated immediately
     â†’ Must generate new key and update client

  4. App exists in database?
     â†’ SELECT * FROM apps WHERE id = '{app_id}';

Solution:
  Re-generate API key:
    â†’ POST /internal/apps/{app_id}/api-key with Bearer token
    â†’ Copy new key to client
    â†’ Update header in next request
```

**Issue: "Webhook events not being processed"**

```
Check:
  1. Event processor running?
     â†’ Check logs for "Event processor started"
     â†’ Verify no errors in handler

  2. Webhook being received?
     â†’ Query: SELECT COUNT(*) FROM webhook_events;
     â†’ Check received_at timestamp

  3. HMAC signature valid?
     â†’ Webhook returns 200? (if 401, signature failed)

  4. Event handler exists for event_type?
     â†’ Check: callEventHandlers.js has handler for call.ring?

  5. Database writable?
     â†’ INSERT test record into calls table

Solution:
  Check logs:
    â†’ grep "event_type: call.ring" /var/log/cti-server/app.log
    â†’ grep "Error processing event" /var/log/cti-server/app.log

  Manually process event:
    â†’ SELECT * FROM webhook_events WHERE processed_at IS NULL LIMIT 1;
    â†’ Copy payload
    â†’ Test handler directly
```

### 2. Performance Troubleshooting

**Slow API Responses (> 1 second)**

```bash
# Check database performance
psql -c "SELECT * FROM pg_stat_statements
          WHERE query LIKE '%calls%'
          ORDER BY total_time DESC LIMIT 5;"

# Identify slow queries
# Common culprits:
#   - Missing index
#   - N+1 query problem
#   - Full table scan

# Check connection pool
curl -H "Authorization: Bearer $INTERNAL_API_SECRET" \
     https://your-cti-server.com/metrics | grep database_connection_pool
# If many waiting: need more connections or optimize query

# Check app memory
curl -H "Authorization: Bearer $INTERNAL_API_SECRET" \
     https://your-cti-server.com/metrics | grep memory_usage
# If > 80%: memory leak or need more RAM
```

**High Error Rate**

```bash
# Check logs for patterns
grep ERROR /var/log/cti-server/app.log | \
  sed 's/.*message: //' | sort | uniq -c | sort -nr
# Shows most common errors

# Check Dialpad API status
curl https://status.dialpad.com/
# If Dialpad down, expect errors

# Check webhook validation failures
grep "Invalid webhook signature" /var/log/cti-server/app.log | wc -l
# If high: check DIALPAD_WEBHOOK_SECRET is correct
```

### 3. Support Resources

**Documentation:**

- [CTI_SERVER_USAGE.md](../CTI_SERVER_USAGE.md) - Architecture & workflows
- [CTI_SERVER_API.md](../CTI_SERVER_API.md) - API endpoint reference
- [PRODUCTION_WORKFLOW.md](../PRODUCTION_WORKFLOW.md) - Step-by-step guides
- [LOCAL_TESTING_GUIDE.md](LOCAL_TESTING_GUIDE.md) - Testing procedures

**Community / Help:**

- Dialpad API docs: https://docs.dialpad.com/
- Node.js: https://nodejs.org/docs/
- PostgreSQL: https://www.postgresql.org/docs/
- Stack Overflow: Tag `dialpad` + `cti`

**Escalation:**

1. Check documentation (above)
2. Review logs and metrics
3. Test in staging environment
4. Contact Dialpad support (for API issues)
5. Check PostgreSQL version compatibility

---

## Quick Reference

### Command Cheat Sheet

```bash
# Start server
npm start

# Start in production mode
NODE_ENV=production npm start

# Test database connection
psql -h localhost -U postgres -d CTI -c "SELECT 1;"

# View logs
tail -f /var/log/cti-server/app.log

# Generate API key
curl -X POST http://localhost:4000/internal/apps/550e8400-e29b-41d4-a716-446655440000/api-key \
  -H "Authorization: Bearer f7d3f1e2b8c4a6e9c3f2b1a4d6e7f8g9h0i1j2k3l4m5n6o7p8q9r0s1t2u3v4w5nshdghjkshasdmzhschgs"

# Check health
curl http://localhost:4000/health

# View metrics
curl -H "Authorization: Bearer f7d3f1e2b8c4a6e9c3f2b1a4d6e7f8g9h0i1j2k3l4m5n6o7p8q9r0s1t2u3v4w5nshdghjkshasdmzhschgs" \
     http://localhost:4000/metrics | jq
```

### Environment Variables Checklist

```bash
â–¡ PORT (default: 4000)
â–¡ NODE_ENV (sandbox/production)
â–¡ DB_HOST, DB_PORT, DB_USER, DB_PASSWORD, DB_NAME
â–¡ DIALPAD_SANDBOX_CLIENT_ID, DIALPAD_SANDBOX_CLIENT_SECRET
â–¡ DIALPAD_PROD_CLIENT_ID, DIALPAD_PROD_CLIENT_SECRET
â–¡ DIALPAD_SANDBOX_REDIRECT_URI, DIALPAD_PROD_REDIRECT_URI
â–¡ DIALPAD_WEBHOOK_SECRET
â–¡ INTERNAL_API_SECRET
â–¡ DIALPAD_SCOPES (optional, has default)
```

---

**Last Updated:** January 30, 2026  
**Version:** 1.0.0  
**Audience:** System Owners, CTOs, DevOps Engineers

For API reference, see [CTI_SERVER_API.md](../CTI_SERVER_API.md)  
For operational workflows, see [PRODUCTION_WORKFLOW.md](../PRODUCTION_WORKFLOW.md)  
For local testing, see [LOCAL_TESTING_GUIDE.md](LOCAL_TESTING_GUIDE.md)
